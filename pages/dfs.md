# 深度优先搜索
**概念** 英语：Depth-First-Search，简称DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。

深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。

**DFS的应用**

迷宫问题<br />
穷举</br >
......

**空间与时间复杂度**

空间复杂度</br>
DFS算法是一个递归算法，需要借助一个递归工作栈，故它的空间复杂度为O(|V|)。<br />
时间复杂度<br />
当以邻接表存储时，时间复杂度为O(|V|+|E|)<br />
当以邻接矩阵存储时，时间复杂度为O(|V|^2)<br />

**首先看下面这张树图**

![Mou icon](http://ocaya4boy.bkt.clouddn.com/WechatIMG5.jpeg?imageView2/1/w/200/h/250)


先列出该树的所有节点

* v1
* v2
* v3
* v4
* v5
* v6
* v7
* v8

然后在看每个节点能邻接点、能访问的最近的那个节点<br />
v1 : v2、v3<br />
v2 : v1、v4、v5<br />
v3 : v1、v6、v7<br />
v4 : v2、v8<br />
v5 : v2、v8<br />
v6 : v3、v7<br />
v7 : v3、v6<br />
v8 : v4、v5<br />

这样基础准备就准备好了，下面我们开始遍历<br />
首先是v1，v1可以访问v2、v3，这个时候标记v1<br />

```
	v1
   /  \
 v2	   v3
```
处理v2的邻节点，v1已经标记了，v4、v5可以访问，入栈v2并标记<br />
队列为：<br />

```
	 v1
    /  \
  v2	v3
 /  \
v4  v5
```
接着处理v4的邻节点，v2已经标记了，v8没有被标记，入栈v4并标记<br />

```
		v1
 	   /  \
	 v2    v3
	/  \
  v4   v5
 /
v8 
```
处理v8的邻节点，v4已经被标记，v5没有，入栈v8并标记<br />

```
		v1
 	   /  \
	 v2    v3
	/  \
  v4   v5
 /
v8 
 \
  v5
```
处理v8下面的v5的节点，都被标记了，入栈v5并标记，停止遍历。<br />
再看一下v2下的v5的节点，因为v5已经被标记了所以除去<br />

```
		v1
 	   /  \
	 v2    v3
	/
  v4
 /
v8 
 \
  v5
```
这样深度搜索v2分支结束。接着处理v3的分支，可以访问的v1，v6，v7后两个没有被标记，所以现在路径为并入栈v3<br />

```
		v1
 	   /  \
	 v2    v3
	/     /  \
  v4    v6    v7
 /
v8 
 \
  v5
```
看v6的节点，v3被标记v7没有，标记并入队v6<br />

```
		v1
 	   /  \
	 v2    v3
	/     /  \
  v4    v6    v7
 /		/
v8 	   v7
 \
  v5
```

看v6下v7的节点，v3、v6都被标记，所以入队标记v7并结束。<br />

```
		v1
 	   /  \
	 v2    v3
	/     /  
  v4    v6    
 /     /
v8 	  v7
 \
  v5
```

最后再处理下v3下v7节点，以为被标记了所以删除，没有其他分支可以继续遍历，整体遍历结束<br />


伪代码：

```
DFS(Node root) 
	root.visited = true;
	foreach(v w)) /*w是v的邻节点*/
		if(!w.visited)
			DFS(w)
```


