# 广度优先搜索
**概念**（引用维基百科）：英语：Breadth-First-Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。

**BFS的应用**

迷宫问题<br />
最短路径<br />
连连看</br >
......

**空间与时间复杂度**
最差情形下，BFS必须寻找所有到可能节点的所有路径，因此其时间复杂度为 O(|V| + |E|)，其中 |V| 是节点的数目，而 |E| 是图中边的数目。
因为所有节点都必须被储存，因此BFS的空间复杂度也为 O(|V| + |E|)，由于对空间的大量需求，因此BFS并不适合解非常大的问题。

**首先看下面这张树图**

![Mou icon](http://ocaya4boy.bkt.clouddn.com/imageWechatIMG6.jpeg?imageView2/1/w/200/h/250)


先列出该树的所有节点

* v1
* v2
* v3
* v4
* v5
* v6
* v7
* v8

然后在看每个节点能邻接点、能访问的最近的那个节点<br />
v1 : v2、v3<br />
v2 : v1、v4、v5<br />
v3 : v1、v6、v7<br />
v4 : v2、v8<br />
v5 : v2、v8<br />
v6 : v3、v7<br />
v7 : v3、v6<br />
v8 : v4、v5<br />

这样基础准备就准备好了，下面我们开始搜索<br />
先创建一个搜索队列，入队根节点v1<br />
现在搜索队列为：<br />
v1
***
然后看v1的邻节点，可以访问v2、v3，那么入队v2、v3(这里访问过的都需要标记一下，防止重复访问，利用标记也能达到广度搜索遍历每个节点的意义)<br />
队列为：<br />
v1 v2 v3
***
看v2的邻节点，v1已经标记了，v4、v5可以访问，那么入队v4、v5并标记<br />
队列为：<br />
v1 v2 v3 v4 v5
***
看v3的邻节点，v1已经标记了，v6、v7没有被标记，入队v6、v7并标记<br />
队列为：<br />
v1 v2 v3 v4 v5 v6 v7
***
v4的邻节点，v2已经被标记，v8可以访问，入队v8并标记<br />
队列为：<br />
v1 v2 v3 v4 v5 v6 v7 v8
***
v5的邻节点，都被标记了，没有节点需要入队<br />
v6的邻节点，都被标记了，没有节点需要入队<br />
v7的邻节点，都被标记了，没有节点需要入队<br />
v8的邻节点，都被标记了，没有节点需要入队<br />
节点队列为空停止搜索，
结束<br />
所以最终该树的广度优先遍历结果为 v1 v2 v3 v4 v5 v6 v7 v8

伪代码：

```c
void search(Node root) 
	Queue queue = new Queue();
	root.visited = true;
	queue.push(root);
	while (!Q.empty())
		v = Q.pop()
		foreach (v,w)
			if (!w.visited) 
				w.visited = true
				queue.push(w)

```


